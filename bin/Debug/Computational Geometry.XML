<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Computational Geometry</name>
    </assembly>
    <members>
        <member name="T:DAP.CompGeom.TestGrahamHull">
             <summary>	Test Graham Scan. </summary>
            
             <remarks>	Darrellp, 3/11/2014. </remarks>
        </member>
        <member name="T:DAP.CompGeom.Geometry">
             <summary>	Static class to provide geometric utility functions on points. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
        </member>
        <member name="F:DAP.CompGeom.Geometry.Tolerance">
            Tolerance we use in "near enough" calculations
        </member>
        <member name="M:DAP.CompGeom.Geometry.FCloseEnough(System.Double,System.Double)">
             <summary>	True if two values are "essentially" equal (i.e., equal within tolerance). </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="a">	First value. </param>
             <param name="b">	Second value. </param>
            
             <returns>	True if values are essentially equal, else false. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.FCloseEnough(DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	True if two points are "essentially" equal. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">	First point. </param>
             <param name="pt2">	Second point. </param>
            
             <returns>	True if they're "equal", else false. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.FNearZero(System.Double)">
             <summary>	Determines if a number is equal to zero within tolerance. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="val">	Value to be checked. </param>
            
             <returns>	True if it's near zero, else false. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.Dot(DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Dot product of two points. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">	First point. </param>
             <param name="pt2">	Second point. </param>
            
             <returns>	Dot product. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.PtToLineDistance(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Point to line distance. </summary>
            
             <remarks>	
             This is a SIGNED distance - positive if ptTest is the lefts of the line looking from ptLine1
             to ptLine2, negative if it's on the right side.
             
             Darrellp, 2/27/2011. 
             </remarks>
            
             <param name="ptTest">	Test point that we measure the distance from. </param>
             <param name="ptLine1">	One point on the line. </param>
             <param name="ptLine2">	Another point on the line. </param>
            
             <returns>	Distance from the point to the line. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.IQuad(DAP.CompGeom.PointD)">
             <summary>	
             Gives an index for the quad a point appears in as follows: 
             3 | 0
             --+--
             2 | 1. 
             </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt">	Point to evaluate. </param>
            
             <returns>	Quadrant index. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.MidPoint(DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Midpoint between two other points. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">	First point. </param>
             <param name="pt2">	Second point. </param>
            
             <returns>	Midpoint. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.SignedArea(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	
             Signed area of the triangle between three points.  This routine is fundamental to a number of
             other geometry routines.  It's positive if the three points are in counterclockwise order,
             negative otherwise and it's absolute value is the area of the triangle. 
             </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">	First point. </param>
             <param name="pt2">	Second point. </param>
             <param name="pt3">	Third point. </param>
            
             <returns>	Signed area of the triangle. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.ICcw(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Determine if pt1, pt2, pt3 occur in Counter Clockwise order. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">	First point. </param>
             <param name="pt2">	Second point. </param>
             <param name="pt3">	Third point. </param>
            
             <returns>	1 if they appear in CCW order, -1 if CW order and 0 if they're linear. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.Area(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Area of triangle defined by three points. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">	First point. </param>
             <param name="pt2">	Second point. </param>
             <param name="pt3">	Third point. </param>
            
             <returns>	triangle area. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.FLeft(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	
             Determine if the test point is to the left of the line looking from ptSegmentStart to
             ptSegmentEnd. 
             </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="ptSegmentStart">	Start point. </param>
             <param name="ptSegmentEnd">		End point. </param>
             <param name="ptTest">			Test point. </param>
            
             <returns>	true if test point is to the left of the line segment, else false. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.FCollinear(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Determine if three points are essentially collinear. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">	First point. </param>
             <param name="pt2">	Second point. </param>
             <param name="pt3">	Third point. </param>
            
             <returns>	True if points are (essentially) collinear, else false. </returns>
        </member>
        <member name="T:DAP.CompGeom.Geometry.CrossingType">
             <summary>	Values that represent CrossingType for segment to segment intersection. </summary>
            
             <remarks>	Darrellp, 2/24/2011. </remarks>
        </member>
        <member name="F:DAP.CompGeom.Geometry.CrossingType.Edge">
            <summary> Segments overlap and are collinear.  </summary>
        </member>
        <member name="F:DAP.CompGeom.Geometry.CrossingType.Vertex">
            <summary> The endpoing of one segment lies on the other and they are not collinear.  </summary>
        </member>
        <member name="F:DAP.CompGeom.Geometry.CrossingType.Normal">
            <summary> Normal crossing.  </summary>
        </member>
        <member name="F:DAP.CompGeom.Geometry.CrossingType.NonCrossing">
            <summary> Segments are parallel and do not cross.  </summary>
        </member>
        <member name="M:DAP.CompGeom.Geometry.SegSegInt(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD@)">
             <summary>	Does segment to segment crossings. </summary>
            
             <remarks>	
             Based on code from Computational Geometry in C by Joseph O'Rourke.
             
             Darrellp, 2/24/2011. 
             </remarks>
            
             <param name="seg1Pt1">	The first point of the segment 1. </param>
             <param name="seg1Pt2">	The second point of the segment 1. </param>
             <param name="seg2Pt1">	The first point of segment 2. </param>
             <param name="seg2Pt2">	The second point of segment 2. </param>
             <param name="pPt">		[out] The intersection if any. </param>
            
             <returns>	A crossing type as outlined above. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.Between(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Determines if point B lies between points A and C. </summary>
            
             <remarks>	
             Based on code from Computational Geometry in C by Joseph O'Rourke.
             
             Darrellp, 2/24/2011. 
             </remarks>
            
             <param name="ptSegEndpoint1">	a point. </param>
             <param name="ptSegmentEndpoint2">	The point. </param>
             <param name="ptTest">	The point. </param>
            
             <returns>	true if it succeeds, false if it fails. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.Distance(DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Euclidean distance between two points. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">	First point. </param>
             <param name="pt2">	Second point. </param>
            
             <returns>	Distance between the two points. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.DistanceSq(DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Euclidean distance between two points. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">	First point. </param>
             <param name="pt2">	Second point. </param>
            
             <returns>	Distance between the two points. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.ManhattanDistance(DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	
             Manhattan Distance between two points.  Quicker metric for short distances than the Euclidean
             one. 
             </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">	First point. </param>
             <param name="pt2">	Second point. </param>
            
             <returns>	Manhattan distance. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.ParabolicCut(DAP.CompGeom.PointD,DAP.CompGeom.PointD,System.Double)">
             <summary>	
             Determine the x coordinate where the parabolas with focus at pt1 and pt2 intersect between
             the two points. The directrix for both parabolas is the line y = ys.
             </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <exception cref="T:System.InvalidOperationException">	Thrown when the requested operation is
             												invalid. </exception>
            
             <param name="pt1">	First focus. </param>
             <param name="pt2">	Second focus. </param>
             <param name="ys">	Y coordinate of the directrix. </param>
            
             <returns>	X coordinate of the intersection of the two parabolas. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.ICompareCw(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Compares absolute clockwise angles from the y axis. </summary>
            
             <remarks>	
             This compares the absolute angle of (ptCenter,pt1) with (ptCenter,pt2) measured clockwise
             from the positive y axis. 
             </remarks>
            
             <param name="ptCenter">	Center of the angle formed. </param>
             <param name="pt1">		First point in check. </param>
             <param name="pt2">		Second point in check. </param>
            
             <returns>	Comparison of absolute angle. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.PointInConvexPoly(DAP.CompGeom.PointD,System.Collections.Generic.IEnumerable{DAP.CompGeom.PointD})">
             <summary>	Determines if a point is in the interior of a convex polygon. </summary>
            
             <remarks>	
             No check is made for the convexity of the polygon and it must be enumerated in CCW order.
             Points on the border are not considered to be in the interior.
             
             Darrellp, 2/25/2011. 
             </remarks>
            
             <param name="ptTest">	Test point. </param>
             <param name="poly">		The points enumerating the polygon in CCW order. </param>
            
             <returns>	true if ptTest is in the polygon, false if it fails. </returns>
        </member>
        <member name="M:DAP.CompGeom.Geometry.FFindCircumcenter(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD@)">
             <summary>	
             Determine the center of a circle passing through three points in the plane.  Most of this is
             ugly math generated from Mathematica. 
             </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt1">		First point. </param>
             <param name="pt2">		Second point. </param>
             <param name="pt3">		Third point. </param>
             <param name="ptCenter">	[out] out parameter returning the circumcenter. </param>
            
             <returns>	
             False if the three points lie on a line in which case the circumcenter is not valid.  True
             otherwise and the returned point is the circumcenter. 
             </returns>
        </member>
        <member name="T:DAP.CompGeom.ConvexPolyIntersection">
             <summary>	Static class to hold the convex poly intersection routine. </summary>
            
             <remarks>	Darrellp, 2/23/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.ConvexPolyIntersection.FindIntersection(System.Collections.Generic.IEnumerable{DAP.CompGeom.PointD},System.Collections.Generic.IEnumerable{DAP.CompGeom.PointD})">
             <summary>	Finds the intersection of two convex polygons. </summary>
            
             <remarks>	<para>No check is made for convexity.  The enumerables must yield the points in counterclockwise
             order.</para>
             
             <para>This code works by looking for intersections between the two polygons.  If there is no intersection
             then no points will be returned even if one is wholly contains within the other.  Putting a check in for
             this case is often unnecessary and so we leave it out here and plan on incorporating it in a separate
             method at a later date.</para>
             
             <para>This is based on the code in "Computational Geometry in C" by Joseph O'Rourke.</para>
             
             Darrellp, 2/23/2011. </remarks>
            
             <param name="poly1Enum">	The polygon 1 enum. </param>
             <param name="poly2Enum">	The polygon 2 enum. </param>
            
             <returns>	An enumeration of the points in the intersection. </returns>
        </member>
        <member name="T:DAP.CompGeom.TestConvexIntersect">
             <summary>	Test convex polygon intersection. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.TestConvexIntersect.TestIntersection">
            <summary>
            
            </summary>
        </member>
        <member name="T:DAP.CompGeom.IPriorityQueueElement">
             <summary>	
             In a priority queue which supports deletion, elements must keep track of their position
             within the queue's heap list.  This interface supports that. 
             </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.IPriorityQueueElement.SetIndex(System.Int32)">
            <summary>
             This is called when the priority queue needs to store it's index
            </summary>
            <param name="i">The index to be stored</param>
        </member>
        <member name="P:DAP.CompGeom.IPriorityQueueElement.Index">
            <summary>
             Returns the index stored in SetIndex
            </summary>
        </member>
        <member name="T:DAP.CompGeom.PointD">
             <summary>	Double precision points. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
        </member>
        <member name="F:DAP.CompGeom.PointD.X">
            <summary> The x coordinate </summary>
        </member>
        <member name="F:DAP.CompGeom.PointD.Y">
            <summary> The y coordinate </summary>
        </member>
        <member name="F:DAP.CompGeom.PointD.Cookie">
            <summary> Cookie to hold arbitrary information for the user </summary>
        </member>
        <member name="M:DAP.CompGeom.PointD.#ctor(System.Double,System.Double)">
             <summary>	Constructor. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="x">	The x coordinate. </param>
             <param name="y">	The y coordinate. </param>
        </member>
        <member name="M:DAP.CompGeom.PointD.#ctor(System.Double,System.Double,System.Object)">
             <summary>	Constructor. </summary>
            
             <remarks>	Darrellp, 2/20/2011. </remarks>
            
             <param name="x">		The x coordinate. </param>
             <param name="y">		The y coordinate. </param>
             <param name="cookie">	pt1 cookie to hold user specified info in. </param>
        </member>
        <member name="M:DAP.CompGeom.PointD.ToString">
             <summary>	Convert this object into a string representation. </summary>
            
             <remarks>	Darrellp, 2/23/2011. </remarks>
            
             <returns>	A string representation of this object. </returns>
        </member>
        <member name="M:DAP.CompGeom.PointD.Flip90Ccw">
             <summary>	Returns a vector 90 degrees in a CCW direction from the original. </summary>
            
             <remarks>	Darrellp, 2/27/2011. </remarks>
            
             <returns>	Vector 90 degrees from original. </returns>
        </member>
        <member name="M:DAP.CompGeom.PointD.Length">
             <summary>	returns the distance from the origin to the point. </summary>
            
             <remarks>	Darrellp, 2/27/2011. </remarks>
            
             <returns>	Length of the point considered as a vector. </returns>
        </member>
        <member name="M:DAP.CompGeom.PointD.Normalize">
             <summary>	Returns a normalized version of the point. </summary>
            
             <remarks>	Darrellp, 2/27/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.PointD.op_Subtraction(DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Subtract two PointDs. </summary>
            
             <remarks>	Darrellp, 2/23/2011. </remarks>
            
             <param name="pt1">	First PointD. </param>
             <param name="pt2">	Second PointD. </param>
            
             <returns>	The result of the operation. </returns>
        </member>
        <member name="M:DAP.CompGeom.PointD.op_Multiply(DAP.CompGeom.PointD,System.Double)">
             <summary>	Multiply by a scalar. </summary>
            
             <remarks>	Darrellp, 2/23/2011. </remarks>
            
             <param name="pt">	Point to be multiplied. </param>
             <param name="v">	Scalar to multiply by. </param>
            
             <returns>	The result of the operation. </returns>
        </member>
        <member name="M:DAP.CompGeom.PointD.op_Addition(DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Subtract two PointDs. </summary>
            
             <remarks>	Darrellp, 2/23/2011. </remarks>
            
             <param name="pt1">	First PointD. </param>
             <param name="pt2">	Second PointD. </param>
            
             <returns>	The result of the operation. </returns>
        </member>
        <member name="M:DAP.CompGeom.PointD.op_Implicit(DAP.CompGeom.PointD)~System.Drawing.PointF">
             <summary>	PointF casting operator. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="pt">	The PointD. </param>
            
             <returns>	The PointF value of this PointD. </returns>
        </member>
        <member name="M:DAP.CompGeom.PointD.Equals(System.Object)">
             <summary>	Compares this vector with another one. </summary>
            
             <remarks>	Darrellp, 2/23/2011. </remarks>
            
             <param name="obj">	The object to compare to this object. </param>
            
             <returns>	true if the objects are considered equal, false if they are not. </returns>
        </member>
        <member name="M:DAP.CompGeom.PointD.GetHashCode">
             <summary>	Retrieves a hashcode that is dependent on the elements. </summary>
            
             <remarks>	Darrellp, 2/23/2011. </remarks>
            
             <returns>	The hashcode. </returns>
        </member>
        <member name="T:DAP.CompGeom.PriorityQueue`1">
             <summary>	A priority queue implemented as an array.  This is a pretty standard implementation. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
        </member>
        <member name="F:DAP.CompGeom.PriorityQueue`1.LstHeap">
            <summary>
            Array to keep elements in.  C# lists are actually implemented as arrays.  This is contrary
            to everything I learned about the terms "array" and "list", but that's nonetheless the way
            they're implemented in the CLR Framework.
            </summary>
        </member>
        <member name="P:DAP.CompGeom.PriorityQueue`1.Count">
            <summary>
             Count of items in the priority queue
            </summary>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.Add(`0)">
             <summary>	Insert a value into the priority queue. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="val">	Value to insert. </param>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.Peek">
             <summary>	Return the maximal element in the queue. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <exception cref="T:System.IndexOutOfRangeException">	Trying to peek at an empty priority queue. </exception>
            
             <returns>	Maximal element in the queue. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.Pop">
             <summary>	Remove and return the maximal element in the queue. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <exception cref="T:System.IndexOutOfRangeException">	Thrown when the priority queue is empty. </exception>
            
             <returns>	Maximal element. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.SetAt(System.Int32,`0)">
             <summary>	Sets an element in the list we keep our heap elements in </summary>
            
             <remarks>
             This is the only way elements should be inserted into LstHeap.  This ensures, among other things,
             that the elements in a queue with deletions always have their held indices up to date.
             Darrellp, 2/17/2011. </remarks>
            
             <param name="i">	The index into LstHeap. </param>
             <param name="val">	The value to be set. </param>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.RightSonExists(System.Int32)">
             <summary>	Queries if a given right son exists. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	The index of the parent. </param>
            
             <returns>	true if the right son exists. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.LeftSonExists(System.Int32)">
             <summary>	Queries if a given left son exists. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	The index of the parent. </param>
            
             <returns>	true if the left son exists. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.ParentIndex(System.Int32)">
             <summary>	Index of parent node. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	Child's index. </param>
            
             <returns>	Index to the parent. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.LeftChildIndex(System.Int32)">
             <summary>	Index of left child's node. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	Parent's index. </param>
            
             <returns>	Index to the left child. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.RightChildIndex(System.Int32)">
             <summary>	Index of right child's node. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	Parent's index. </param>
            
             <returns>	Index to the right child. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.ArrayVal(System.Int32)">
             <summary>	Array value at index i. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	The index. </param>
            
             <returns>	Array value at i. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.Parent(System.Int32)">
             <summary>	Returns the parent. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	The index of the child. </param>
            
             <returns>	The parent. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.Left(System.Int32)">
             <summary>	Returns the left child. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	The index of the parent. </param>
            
             <returns>	The left child. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.Right(System.Int32)">
             <summary>	Returns the right child. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	The index of the parent. </param>
            
             <returns>	The right child. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.Swap(System.Int32,System.Int32)">
             <summary>	Swaps two elements of the priority queue. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	The index of the first element. </param>
             <param name="j">	The index of the second element. </param>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.UpHeap(System.Int32)">
             <summary>	Move an element up the heap to it's proper position </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="i">	The index of the element to move. </param>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.DownHeap(System.Int32)">
             <summary>	Move an element down the heap to it's proper position. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="i">	The index of the element to move. </param>
        </member>
        <member name="F:DAP.CompGeom.PriorityQueue`1.StrIndent">
            <summary> The string indent </summary>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.TraceElement(System.Int32,`0)">
             <summary>	Trace element. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="iPos">	The position. </param>
             <param name="val">	The value. </param>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.PrintTree">
             <summary>	Print tree. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.PrintTree(System.Int32)">
             <summary>	Print tree. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="i">	The index into LstHeap. </param>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueue`1.GetEnumerator">
             <summary>	Gets an enumerator for the items in the queue. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <returns>	The enumerator. </returns>
        </member>
        <member name="T:DAP.CompGeom.TestPriorityQueue">
            <summary>
            
            </summary>
        </member>
        <member name="T:DAP.CompGeom.PriorityQueueWithDeletions`1">
             <summary>	Priority queue with deletions. </summary>
            
             <remarks>
             This is the same as the priority queue but the elements stored in it must satisfy the
             IPriorityQueueElement interface.  This allows us to store and retrieve our local indices in
             the objects so when we go to delete them we can query them for their index and then remove
             the element at that index.
             	
             Darrellp, 2/17/2011. 
             </remarks>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueueWithDeletions`1.Pop">
             <summary>	Removes and returns the largest object. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <returns>	The previous largest object. </returns>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueueWithDeletions`1.Delete(`0)">
             <summary>	Delete a value from the heap. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="val">	Value to remove. </param>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueueWithDeletions`1.TraceElement(System.Int32,`0)">
             <summary>	Trace element. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="iPos">	The position. </param>
             <param name="val">	The value. </param>
        </member>
        <member name="M:DAP.CompGeom.PriorityQueueWithDeletions`1.SetAt(System.Int32,`0)">
             <summary>	
             This override is the magic that makes the deletions work by keeping track of the index a
             particular element is moved to. 
             </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="i">	The index. </param>
             <param name="val">	The value. </param>
        </member>
        <member name="T:DAP.CompGeom.Beachline">
             <summary>	
             The beachline is the union of all the parabolas formed from all sites.  This is actually
             maintained as a height balanced tree as suggested in the book by de Berg, et al. 
             </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.Beachline.#ctor">
             <summary>	Default constructor. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
        </member>
        <member name="P:DAP.CompGeom.Beachline.NdRoot">
             <summary>	Gets or the root node of the beachline tree. </summary>
            
             <value>	The root node of the beachline tree. </value>
        </member>
        <member name="M:DAP.CompGeom.Beachline.LfnSearchNode(System.Double,System.Double)">
             <summary>	
             Do a binary search down the tree looking for the leaf node which covers the passed in X
             coordinate. 
             </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="xSite">		X coordinate. </param>
             <param name="yScanLine">	Where the scan line is at now. </param>
            
             <returns>	Leaf node for parabola covering xSite. </returns>
        </member>
        <member name="M:DAP.CompGeom.Beachline.RemoveNodeAndInsertVertex(DAP.CompGeom.CircleEvent,DAP.CompGeom.LeafNode,DAP.CompGeom.PointD,DAP.CompGeom.EventQueue)">
             <summary>	
             Remove a parabola node from the beachline since it's being squeezed out and insert a vertex
             into the voronoi diagram. 
             </summary>
            
             <remarks>	
             This happens when a circle event occurs.  It's a rather delicate operation. From the point of
             view of the voronoi diagram, we have two edges from above coming together into the newly
             created vertex and a new edge created which descends below it.  This is really where the meat
             of actually creating the voronoi diagram occurs.  One of the important details which seems to
             be left totally out of the book is the importance of keeping accurate left and right sibling
             pointers on the leaf nodes.  Since each leaf node represents a parabola in the beachline,
             these pointers represent the set of parabolas from the left to the right of the beachline.
             In a case like this where a parabola is being squeezed out, it's left and right siblings will
             not butt up against each other forming a new edge and we need to be able to locate both these
             nodes in order to make everything come out right.
             
             This is very persnickety code.
             </remarks>
            
             <param name="cevt">				Circle event which caused this. </param>
             <param name="lfnEliminated">	Leaf node for the parabola being eliminated. </param>
             <param name="voronoiVertex">	The new vertex to be inserted into the voronoi diagram. </param>
             <param name="evq">				Event queue. </param>
        </member>
        <member name="M:DAP.CompGeom.Beachline.RemoveLeaf(DAP.CompGeom.LeafNode)">
             <summary>	Remove a leaf node. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="lfn">	node to remove. </param>
        </member>
        <member name="M:DAP.CompGeom.Beachline.SetZeroLengthFlagOnPolys(DAP.CompGeom.FortuneEdge,DAP.CompGeom.FortuneEdge)">
             <summary>	One of our incoming edges is zero length so note it properly in the polygons. </summary>
            
             <remarks>	
             This happens when cocircular generators cause more than one circle event at the same
             location. 
             </remarks>
            
             <param name="edgeNearSibling">	Immediate sibling. </param>
             <param name="edgeFarSibling">	Far sibling. </param>
        </member>
        <member name="M:DAP.CompGeom.Beachline.RemoveAssociatedCircleEvents(DAP.CompGeom.LeafNode,DAP.CompGeom.EventQueue)">
             <summary>	Delete any circle events associated with the leaf node. </summary>
            
             <remarks>	
             Circle events are composed of three adjacent leaf nodes so the ones	associated with us
             include the one directly on us and the ones on our left and right siblings. 
             </remarks>
            
             <param name="lfnEliminated">	Leaf node being eliminated. </param>
             <param name="evq">				Event queue. </param>
        </member>
        <member name="M:DAP.CompGeom.Beachline.ICcwVoronoi(DAP.CompGeom.PointD,DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Catch special circle events and disallow them. </summary>
            
             <remarks>	
             In the book it says to add a circle event if it isn't already in the queue.  That seems a bit
             wasteful to me - search the whole queue every time you add a circle event?  There has to be a
             better way.  This routine is the alternative.  Just a few checks on the circle parameters
             ensures that they'll only enter the queue once.  Much better than a searh of the queue. It's essentially
             an extension of the counter clockwise generic routine which deals with collinear points as though
             they were points on an infinitely large circle.
             </remarks>
            
             <param name="pt1">	First point for proposed circle event. </param>
             <param name="pt2">	Second point for proposed circle event. </param>
             <param name="pt3">	Third point for proposed circle event. </param>
            
             <returns>	Acceptable if less than or equal to zero, else rejected. </returns>
        </member>
        <member name="M:DAP.CompGeom.Beachline.CreateCircleEventFromTriple(DAP.CompGeom.LeafNode,DAP.CompGeom.LeafNode,DAP.CompGeom.LeafNode,System.Double,DAP.CompGeom.EventQueue)">
             <summary>	Create a circle event from a triple of leaf nodes. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="lfnLeft">		Leaf node representing the leftmost parabola. </param>
             <param name="lfnCenter">	Leaf node representing the center parabola. </param>
             <param name="lfnRight">		Leaf node representing the rightmost parabola. </param>
             <param name="yScanLine">	Where the scan line is located. </param>
             <param name="evq">			Event queue. </param>
        </member>
        <member name="M:DAP.CompGeom.Beachline.NdInsertAtSameY(DAP.CompGeom.LeafNode,DAP.CompGeom.LeafNode,DAP.CompGeom.InternalNode,DAP.CompGeom.InternalNode,System.Boolean)">
             <summary>	Handle the top N nodes located on a single horizontal line. </summary>
            
             <remarks>	
             This only handles the corner case where the top N nodes are on the same horizontal
             line.  In that case the parabolas from previous points are vertically straight up and only
             project to a single point on the x axis so that the beachline is a series of points rather
             than a series of parabolas.  When that is the case we can't "intersect" new points with
             parabolas that span the x axis.  After the scanline passes that initial set of topmost points,
             there will always be a parabola which projects to the entire x axis so no need for this
             special handling. Normally, we produce two new parabolas at a site event like this - the new
             parabola for the site itself and the new parabola produced when we split the parabola above
             us.  In this case there is no parabola above us so we only produce one new parabola - the one
             inserted by the site. 
             </remarks>
            
             <param name="lfn">				LeafNode of the (degenerate) parabola nearest us. </param>
             <param name="lfnNewParabola">	LeafNode we're inserting. </param>
             <param name="innParent">		Parent of lfnOld. </param>
             <param name="innSubRoot">		Root of the tree. </param>
             <param name="fLeftChild">		Left child of innParent. </param>
        </member>
        <member name="M:DAP.CompGeom.Beachline.InsertAtDifferentY(DAP.CompGeom.LeafNode,DAP.CompGeom.LeafNode,DAP.CompGeom.InternalNode)">
             <summary>	Insert a new parabola into the beachline when the beachline spans the X axis. </summary>
            
             <remarks>	
             This is the normal case.  We insert our new parabola and split the parabola above our site in
             two. This means one new leaf node is created for leftmost of the two nodes in the split (the
             old lfn is recycled to become the right node of the split).  Also a new internal node to
             parent all this. 
             </remarks>
            
             <param name="lfnOld">			Parabola above the new site. </param>
             <param name="lfnNewParabola">	parabola for the new site. </param>
             <param name="innSubRoot">		Parent node of both lfnOld and lfnNewParabola represneting
             								the breakpoint between them. </param>
        </member>
        <member name="M:DAP.CompGeom.Beachline.NdCreateInsertionSubtree(DAP.CompGeom.LeafNode,DAP.CompGeom.SiteEvent)">
             <summary>	Insert a new LeafNode into the tree. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="lfn">	Place to put the new leaf node. </param>
             <param name="evt">	The event to insert. </param>
            
             <returns>	. </returns>
        </member>
        <member name="M:DAP.CompGeom.Beachline.CreateCircleEventsFromSiteEvent(DAP.CompGeom.LeafNode,DAP.CompGeom.LeafNode,System.Double,DAP.CompGeom.EventQueue)">
            <summary>
            Create the new circle events that arise from a site event
            </summary>
            <param name="lfnLeft">Node to the left</param>
            <param name="lfnRight">Node to the right</param>
            <param name="yScanLine">Scan line position</param>
            <param name="evq">Event queue</param>
        </member>
        <member name="M:DAP.CompGeom.Beachline.PolyInsertNode(DAP.CompGeom.SiteEvent,DAP.CompGeom.EventQueue)">
             <summary>	Insert a new polygon arising from a site event. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="evt">	Site event causing the new polygon. </param>
             <param name="evq">	Event queue. </param>
        </member>
        <member name="T:DAP.CompGeom.EventQueue">
             <summary>	Queue of fortune events. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.EventQueue.AddCircleEvent(DAP.CompGeom.CircleEvent)">
             <summary>	Adds a circle event. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="cevt">	The event to add. </param>
        </member>
        <member name="P:DAP.CompGeom.EventQueue.CircleEvents">
             <summary>	Gets the circle events. </summary>
            
             <value>	The circle events. </value>
        </member>
        <member name="T:DAP.CompGeom.Fortune">
             <summary>	Fortune implements the Fortune algorithm for Voronoi diagrams. </summary>
            
             <remarks>	
             <para>When run initially, Fortune.Voronoi() returns a list of polytons that make up the diagram.
             These can be transformed into a fully blown winged edge data structure if desired.  It's
             input is simply a list of points to calculate the diagram for.  It is based on the
             description of the algorithm given in "Computational Geometry - Algorithms and Applications"
             by M. de Berg et al. with a LOT of details filled in.  Some differences between the book's
             solution and mine:</para>
             
             <para>The book suggests a doubly connected edge list.  I prefer a winged edge data structure.
             Internally I use a structure which is a primitive winged edge structure which contains
             polygons, edges and vertices but not much of the redundancy available in a fully fleshed out
             winged edge, but optionally allow for a conversion to a fully fleshed out winged edge data
             structure.  This conversion is a bit expensive and may not be necessary (for instance, it
             suffices if you want to merely draw the diagram) so is made optional.</para>
             
             <para>Another big difference between this algorithm and the one there is the handling of polygons
             which extend to infinity.  These don't necessarily fit into winged edge which requires a
             cycle of edges on each polygon and another polygon on the opposite site of each edge.  The
             book suggests surrounding the diagram with a rectangle to solve this problem.  Outside of the
             fact that I still don't see how that truly solves the problem (what's on the other side of
             the edges of the rectangle?), I hate the solution which introduces a bunch of spurious
             elements which have nothing to do with the diagram. I solve it by using a "polygon at
             infinity" and a bunch of "sides at infinity".  The inspiration for all this is projective
             geometry which has a "point at infinity".  This maintains the winged edge structure with the
             introduction of these "at infinity" elements which are natural extensions of the diagram
             rather than the ugly introduced rectangle suggested in the book.  They also allow easy
             reference to these extended polygons.  For instance, to enumerate them, just step off all the
             polygons which "surround" the polygon at infinity.</para>
             
             <para>I take care of a lot of bookkeeping details and border cases not mentioned in the book - zero
             length edges, collinear points, degenerate solutions with wholly infinite lines and many other
             minor to major points not specifically covered in the book. </para>
             </remarks>
        </member>
        <member name="M:DAP.CompGeom.Fortune.#ctor(System.Collections.Generic.IEnumerable{DAP.CompGeom.PointD})">
             <summary>	Add all points to the event queue as site events. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="points">	Points whose Voronoi diagram will be calculated. If the library is
             						built for double precision, these should be PointD, else PointF. </param>
        </member>
        <member name="M:DAP.CompGeom.Fortune.InsertPoly(DAP.CompGeom.PointD,System.Int32)">
             <summary>	
             Each polygon in the final solution is associated with a point in the input.  We initialize
             that polygon for this point here. 
             </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
            
             <param name="pt">	The point. </param>
             <param name="index"> Identifying index for this point/poly</param>
            
            <returns>	The polygon produced. </returns>
        </member>
        <member name="P:DAP.CompGeom.Fortune.Polygons">
             <summary>	Gets the list of polygons which make up the voronoi diagram. </summary>
            
             <value>	The polygons. </value>
        </member>
        <member name="P:DAP.CompGeom.Fortune.QevEvents">
             <summary>	Gets or sets the event queue. </summary>
            
             <value>	The event queue. </value>
        </member>
        <member name="P:DAP.CompGeom.Fortune.Bchl">
             <summary>	The beachline which is the primary data structure kept as we sweep 
             downward through the points </summary>
            
             <value>	The bchl. </value>
        </member>
        <member name="M:DAP.CompGeom.Fortune.ComputeVoronoi(System.Collections.Generic.IEnumerable{DAP.CompGeom.PointD})">
             <summary>	Calculates the voronoi winged edge data structure for a collection of points. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="pts">	The points we want the Voronoi diagram for. </param>
            
             <returns>	The calculated voronoi diagram. </returns>
        </member>
        <member name="M:DAP.CompGeom.Fortune.LloydRelax(DAP.CompGeom.WingedEdge{DAP.CompGeom.FortunePoly,DAP.CompGeom.FortuneEdge,DAP.CompGeom.FortuneVertex},System.Double,System.Collections.Generic.IEnumerable{DAP.CompGeom.PointD},System.Double)">
             <summary>	Lloyd relaxation. </summary>
            
             <remarks>	
             This routine performs a single Lloyd relaxation on a fortune winged edge structure.  That
             means the points for the voronoi diagram are moved to the centroid of their cell and the
             voronoi algorithm is run again.  In order to do this we have to be able to clip the infinite
             polygons or else their centroid is undefined so a clipping polygon is passed in to clip to.
             Also, as usual, we need a ray length to know how far to extend any infinite rays.  This
             should be a large enough value that all rays extend to the side of the clipping polygon.
             
             Currently, my clipping algorithm only works for convex polygons so the clipping polygon
             passed in must be convex and the points must be in counterclockwise order.  This works fine
             for clipping to rectangles or voronoi cells which are the two cases I'm currently interested
             in.
             
             Darrellp, 2/24/2011. 
             </remarks>
            
             <param name="we">			WingedEdge structure we'll relax. </param>
             <param name="rayLength">	Length of the rays we extend. </param>
             <param name="polyClip">		The polygon to clip to. </param>
             <param name="strength">		Strength of relaxation.  The default is 1 for "standard"
             							relaxation. 0 has no effect.  Negative values can make it more
             							"spikey". </param>
            
             <returns>	The relaxed Winged Edge structure. </returns>
        </member>
        <member name="M:DAP.CompGeom.Fortune.Voronoi">
             <summary>	Calculates the voronoi diagram. </summary>
            
             <remarks>	Darrellp, 2/17/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.Fortune.BuildWingedEdge">
             <summary>Return the Winged edge structure for the voronoi diagram.</summary>
             <remarks>
             Return the Winged edge structure for the voronoi diagram.  This is a complicated procedure
             with a lot of details to be taken care of as follows:
             <list type="bullet">
             <item>
             Every polygon has to have its edges sorted in clockwise order.
             </item>
             <item>
             Set all the successor edges to each edge and the list of edges to each vertex.
             </item>
             <item>
             Zero length edges are eliminated and their "endpoints" are consolidated.
             </item>
             <item>
             The polygon at infinity and all the edges at infinity must be added
             </item>
             </list>
             
             <para>If the callers only want a list of undifferentiated polygons, they can call Voronoi and
             get such a list.  This is fine for drawing and other things, but doesn't give any kind of
             relationship between elements in diagram.  If that is desired, this routine can be called
             to get a much richer Winged Edge data structure for the diagram.  It is a relatively expensive
             thing to compute which is why it's made separate from the raw voronoi diagram calculations.</para>
             
             <para>NOTE ON THE POLYGON AT INFINITY: In the WingedEdge structure each polygon has a list of edges
             with another polygon on the other side of each edge.  This poses a bit of a difficulty for
             the polygons in a Voronoi diagram whose edges are rays to infinity.  We'll call these
             "infinite polygons" for convenience.  The solution we use in our WingedEdge data structure is
             to produce a single "polygon at infinity" (not to be confused with the infinite polygons
             previously mentioned) and a series of edges at infinity which "separate" the infinite
             polygons from the polygon at infinity.  These edges have to be ordered in the same order as
             the infinite polygons around the border.  All of this is done in AddEdgeAtInfinity().</para>
             
             <para>In order to set up the polygon at infinity we have to start with an infinite polygon and
             then work our way around the exterior of the diagram, moving from one infinite polygon to
             another and adding them to the list of polygons "adjacent" to the polygon at infinity.  We
             keep track of the first infinite polygon we find to use it as the starting polygon in that
             process.</para>
             
             Darrellp, 2/17/2011. </remarks>
            
             <returns>	The winged edge structure for the diagram. </returns>
        </member>
        <member name="M:DAP.CompGeom.Fortune.RecalcLeadingInfiniteEdge(DAP.CompGeom.FortunePoly)">
             <summary>	Recalc leading infinite edge. </summary>
            
             <remarks>	
             This is a lot of code for a very corner case.  If an initial infinite polygon has some of
             it's edges removed because they were zero length then a previously calculated index for the
             leading infinite edge will be wrong and we have to recalculate it which is the purpose of
             this little routine. Darrellp, 2/18/2011. 
             </remarks>
            
             <param name="polyInfinityStart">	The starting infinite polygon. </param>
            
             <returns>	The newly calculated index for the leading edge. </returns>
        </member>
        <member name="M:DAP.CompGeom.Fortune.ProcessPolygonEdges(DAP.CompGeom.FortunePoly,DAP.CompGeom.WingedEdge{DAP.CompGeom.FortunePoly,DAP.CompGeom.FortuneEdge,DAP.CompGeom.FortuneVertex},DAP.CompGeom.FortunePoly@,System.Int32@)">
             <summary>	Process a polygon's edges. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="poly">						Polygon to be processed. </param>
             <param name="we">						WingedEdge structure we'll add the polygon to. </param>
             <param name="polyInfinityStart">		[in,out] The current infinite polygon or null if none
             										yet found. </param>
             <param name="iLeadingInfiniteEdgeCw">	[in,out] The CW leading infinite edge if a new
             										infinite polygon has been found. </param>
        </member>
        <member name="M:DAP.CompGeom.Fortune.AddPolygonAtInfinity(DAP.CompGeom.WingedEdge{DAP.CompGeom.FortunePoly,DAP.CompGeom.FortuneEdge,DAP.CompGeom.FortuneVertex},DAP.CompGeom.FortunePoly,System.Int32)">
             <summary>	
             Set up the polygon at infinity.  The main difficulty here consists in traversing around the
             infinite polygons at the edge of the diagram in order. 
             </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="we">				WingedEdge structure we'll add the polygon at infinity to. </param>
             <param name="polyStart">		Infinite polygon to start the polygon at infinity's polygon list with. </param>
             <param name="iLeadingEdgeCw">	Starting infinite edge. </param>
        </member>
        <member name="M:DAP.CompGeom.Fortune.AddEdgeAtInfinity(DAP.CompGeom.FortunePoly,DAP.CompGeom.FortunePoly,System.Int32,DAP.CompGeom.WeEdge,DAP.CompGeom.FortunePoly@,System.Int32@)">
             <summary>	
             Add an edge at infinity and step the polygon and edge along to the next infinite polygon and
             rayed edge. 
             </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="polyAtInfinity">			Polygon at infinity. </param>
             <param name="poly">						Infinite polygon we're adding the edge to. </param>
             <param name="iLeadingEdgeCw">			index to rayed edge  we start with. </param>
             <param name="edgePreviousAtInfinity">	Edge at infinity we added in the previous infinite
             										polygon. </param>
             <param name="polyNextCcw">				[out] Returns the next infinite polygon to be
             										processed. </param>
             <param name="iLeadingEdgeNext">			[out] Returns the next infinite edge. </param>
            
             <returns>	. </returns>
        </member>
        <member name="M:DAP.CompGeom.Fortune.HookEdgeAtInfinityToVerticesAtInfinity(DAP.CompGeom.FortuneEdge,DAP.CompGeom.FortuneVertex,DAP.CompGeom.FortuneVertex)">
             <summary>	Insert the edge at infinity into the edge list for the vertices at infinity. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="edge">				Edge at infinity being added. </param>
             <param name="leadingVtxCw">		Vertex on the left of infinite poly as we look out. </param>
             <param name="trailingVtxCw">	Vertex on the right. </param>
        </member>
        <member name="M:DAP.CompGeom.Fortune.ProcessEvents">
            <summary>
            Remove events from the queue and handle them one at a time.
            </summary>
        </member>
        <member name="M:DAP.CompGeom.Fortune.Finish">
            <summary>
            Finish up loose ends
            </summary>
        </member>
        <member name="M:DAP.CompGeom.Fortune.FixInfiniteEdges">
             <summary> Set up points at infinity </summary>
             <remarks>
             <para>In the course of processing, edges are created initially with null endpoints.  The endpoints
             are filled in during the course of the Fortune algorithm.  When we finish processing, any null
             endpoints represent "points at infinity" where the edge is a ray or (rarely) an infinitely
             extended line.  We have to go through and fix up any of these loose ends to turn them into
             points at infinity.</para>
             
             <para>This is a lot of really tedious, detail oriented, nitpicky code.  I'd avoid it if I were you.</para>
             </remarks>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.Fortune.ProcessRay(DAP.CompGeom.FortuneEdge)">
             <summary>	Turn a null endpoint of the ray into an infinite vertex. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="edge">	Edge with the null vertex. </param>
        </member>
        <member name="M:DAP.CompGeom.Fortune.SplitDoublyInfiniteEdge(DAP.CompGeom.FortuneEdge)">
             <summary>	Splits a doubly infinite edge. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="edge">	Edge we need to split. </param>
        </member>
        <member name="T:DAP.CompGeom.Fortune.TestVoronoi">
             <summary>	Test voronoi. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.Fortune.TestVoronoi.TestHex">
            <summary>
            
            </summary>
        </member>
        <member name="M:DAP.CompGeom.Fortune.TestVoronoi.TestGeneratorAdds">
            <summary>
            
            </summary>
        </member>
        <member name="M:DAP.CompGeom.Fortune.TestVoronoi.TestProcessEvents">
            <summary>
            
            </summary>
        </member>
        <member name="M:DAP.CompGeom.Fortune.TestVoronoi.TestPerf">
             <summary>	Tests perf. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
        </member>
        <member name="T:DAP.CompGeom.FortuneEdge">
             <summary>	Fortune edge. </summary>
            
             <remarks>
             An edge for a winged edge structure but specifically designed for the voronoi algorithm.
             Darrellp, 2/18/2011.
             </remarks>
        </member>
        <member name="P:DAP.CompGeom.FortuneEdge.FSplit">
             <summary>	Gets or sets a value indicating whether this is part of a split doubly infinite edge. </summary>
            
             <value>	true if split, false if not. </value>
        </member>
        <member name="P:DAP.CompGeom.FortuneEdge.PolyOrderingTestPoint">
             <summary>	Return a point suitable for testing angle around the generator. </summary>
             
             <remarks>	
             When we order the edges in CW or CCW order, we need to get representative points on each edge
             so that we can compare the angle they make with the vertex being tested.  This means they
             have to be on the edge but not at either vertex so that we can order the edges of polygons in
             postprocessing.  This is used in the CompareToVirtual() to effect that ordering. 
             </remarks>
            
             <value>	The polygon ordering test point. </value>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.ToString">
             <summary>	Convert this object into a string representation. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <returns>	A string representation of this object. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.FZeroLength">
             <summary>	Is this edge zero length?  Infinite rays are never zero length. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <returns>	true if the edge is zero length. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.EdgeIndex(System.Boolean)">
             <summary>	Find the index of this edge in an adjacent vertex. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="fStartVertex">	If true, search start vertex, else search end vertex. </param>
            
             <returns>	Index in the vertice's edge list of this edge. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.OtherPoly(DAP.CompGeom.FortunePoly)">
             <summary>	Returns the polygon on the other side of this edge. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="polyThis">	The polygon on "this" side. </param>
            
             <returns>	The polygon on the "other" side. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.FConnectsTo(DAP.CompGeom.FortuneEdge,DAP.CompGeom.FortuneEdge,System.Boolean@,System.Boolean@)">
             <summary>	
             Determine whether two edges connect at a common vertex and if so, how they connect. 
             </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="edge1">					First edge. </param>
             <param name="edge2">					Second edge. </param>
             <param name="fEdge1ConnectsAtStartVtx">	[out] True if edge1 connects to edge2 at its start
             										vertex, else false. </param>
             <param name="fEdge2ConnectsAtStartVtx">	[out] True if edge2 connects to edge1 at its start
             										vertex, else false. </param>
            
             <returns>	true if the edges connect. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.RelabelEndVerticesToStart">
            <summary>	Relabel all the end vertices of this edge to point to it's start vertex. </summary>
            
            <remarks>
            This is done only for zero length edges when they're deleted.  The edges emanating from the
            end vertex of the zero length edge are moved to the start vertex (which is in the same location
            as the end vertex).  Since these will not be ordered with the edges already there we set them to
            unordered.
            	
            Darrellp, 2/19/2011.
            </remarks>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.SpliceEndEdgesIntoStart">
             <summary>	Splice all the end vertices of this edge into the edge list of it's start vertex. </summary>
            
             <remarks>	We do this when removing zero length edges. Darrellp, 2/19/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.ReassignVertexEdges">
             <summary>	Move all the edges on the end vertex to the start. </summary>
            
             <remarks>	
             This is done to removing a zero length edge.  Since the edge is zero length
             we can assume that all the end edges fit in the "wedge" occupied by this edge in the start
             vertices list of edges.  That is, we can assume that we can just splice the end edges into
             the start vertex's list of edges without having to resort based on angle. 
             </remarks>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.AddVertex(DAP.CompGeom.FortuneVertex)">
             <summary>	Add a vertex in the proper place according to _fStartVertexSet. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="vtx">	Vertex to add. </param>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.GetSuccessorEdgesFromVertex(DAP.CompGeom.FortuneVertex,DAP.CompGeom.FortuneEdge@,DAP.CompGeom.FortuneEdge@)">
             <summary>	
             Get the next edge in both the cw and ccw directions from this edge at the given vertex. 
             </summary>
            
             <remarks>	
             This routine is called before they've been set up as winged edges so we have to search them
             out ourselves.  The edges have been ordered in CW order, however.
             
             Darrellp, 2/19/2011. 
             </remarks>
            
             <param name="vtx">		vertex to use. </param>
             <param name="edgeCW">	[out] returned cw edge. </param>
             <param name="edgeCCW">	[out] returned ccw edge. </param>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.GetSuccessorEdgesFrom3ValentVertex(DAP.CompGeom.FortuneVertex,DAP.CompGeom.FortuneEdge@,DAP.CompGeom.FortuneEdge@)">
             <summary>	
             Get the next edge in both the cw and ccw directions from this edge at the given 3 valent
             vertex. 
             </summary>
            
             <remarks>
             This is the simplest and most common case.  It's called before the winged edge stuff is set up
             so we have to search manually.  The edges have been sorted in clockwise order however.
             
             Darrellp, 2/19/2011.
             </remarks>
            
             <param name="vtx">		vertex to use. </param>
             <param name="edgeCW">	[out] returned cw edge. </param>
             <param name="edgeCCW">	[out] returned ccw edge. </param>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.SetOrderedPoly(DAP.CompGeom.FortunePoly)">
             <summary>	
             Place the poly on the proper side of this edge.  We use the generator of the poly to locate
             it properly WRT this edge. 
             </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="poly">	Polygon to locate. </param>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.SetSuccessorEdges">
             <summary>	
             Set up the "wings" for this edge - i.e., it's successor edges in both cw and ccw directions
             at both start and end vertices. 
             </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.HookToWingedEdge(DAP.CompGeom.FortunePoly,DAP.CompGeom.WingedEdge{DAP.CompGeom.FortunePoly,DAP.CompGeom.FortuneEdge,DAP.CompGeom.FortuneVertex})">
             <summary>	Add a poly to the edge and the edge to the winged edge data structure. </summary>
            
             <remarks>	
             This is where we set up the CW and CCW successor and predecessor edges, the polygons on each
             side of the edge, it's start and end vertices.  Also, the edge is added to to start and end
             vertices' edge list and it's actually added to the winged edge structure itself
             
             Darrellp, 2/18/2011. 
             </remarks>
            
             <param name="poly">	Polygon to add. </param>
             <param name="we">	Winged edge structure to add edge to. </param>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.SetPolys(DAP.CompGeom.FortunePoly,DAP.CompGeom.FortunePoly)">
             <summary>	Set up the polygons which surround this edge. </summary>
            
             <remarks>	
             During the sweepline processing we don't necessarily know where the final vertex for an edge
             will be before we know the polygons on each side of the edge so we can't actually determine
             which side of the edge the polygons will lie on.  Consequently, we have to just keep them
             handy until we finally get our second point.
             
             Darrellp, 2/19/2011. 
             </remarks>
            
             <param name="poly1">	First poly. </param>
             <param name="poly2">	Second poly. </param>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.PolyCommon(DAP.CompGeom.FortuneEdge)">
             <summary>	
             Find the common polygon between two edges.  An assertion will be raised if there is no common
             polygon. 
             </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="edge">	Edge to find a common poly with. </param>
            
             <returns>	The common polygon. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortuneEdge.CompareToVirtual(DAP.CompGeom.WeEdge)">
             <summary>	Compare two edges based on their cw order around a common generator. </summary>
            
             <remarks>	
             It is an error to compare edges which do not have a common generator so this is only a
             "partial" comparer which is probably strictly verboten according to C# rules, but we have to
             do it in order to use the framework Sort routine to sort edges around a generator. 	
             
             Darrellp, 2/19/2011. 
             </remarks>
            
             <param name="edgeIn">	Edge to compare. </param>
            
             <returns>	Comparison output. </returns>
        </member>
        <member name="T:DAP.CompGeom.FortuneEvent">
             <summary>	
             A class for the events that drive the Fortune algorithm 
             </summary>
            
             <remarks>	
             The fortune algorithm works by moving a sweepline down through the sites of the diagram.
             During that movement, events are added, removed and popped from a priority queue.  Those
             events each have a y coordinate and the event with the largest y coordinate is popped out of
             the priority queue.  These events are of two types: circle events (CircleEvent) and site
             events (SiteEvent).  FortuneEvent is an abstract class which serves as the base for both
             these types of event.
             
             Darrellp, 2/21/2011. 
             </remarks>
        </member>
        <member name="P:DAP.CompGeom.FortuneEvent.Pt">
             <summary>	Gets or sets the point where this event occurs. </summary>
            
             <value>	The point where this event occurs. </value>
        </member>
        <member name="M:DAP.CompGeom.FortuneEvent.System#IComparable#CompareTo(System.Object)">
            <summary>
            Compare two events.  We order them using y coordinate first and then x coordinate.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:DAP.CompGeom.FortuneEvent.Handle(DAP.CompGeom.Fortune)">
            <summary>
            Handle the event
            </summary>
            <param name="fortune">Fortune data structure being built</param>
        </member>
        <member name="M:DAP.CompGeom.FortuneEvent.CreateCircleEvent(DAP.CompGeom.FortunePoly,DAP.CompGeom.FortunePoly,DAP.CompGeom.FortunePoly,System.Double)">
             <summary>	Creates a circle event. </summary>
            
             <remarks>Circle events are created at the circumcenters of three sites - the sites for poly1/2/3.</remarks>
             <param name="poly1">		The first polygon. </param>
             <param name="poly2">		The second polygon. </param>
             <param name="poly3">		The third polygon. </param>
             <param name="yScanLine">	The y coordinate scan line. </param>
            
             <returns>	A new circle event. </returns>
        </member>
        <member name="T:DAP.CompGeom.SiteEvent">
             <summary>	
             Site events are inserted into the priority queue when the fortune object is created. See its
             constructor for details. 
             </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.SiteEvent.Handle(DAP.CompGeom.Fortune)">
             <summary>	Handle a site event.  This is done by adding a polgyon/parabola to the beachline. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="fortune">	The fortune object to update. </param>
        </member>
        <member name="T:DAP.CompGeom.CircleEvent">
             <summary>	Circle events snuff out a parabola on the beachline. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.CircleEvent.Handle(DAP.CompGeom.Fortune)">
             <summary>	Handle a circle event.  Snuff out the a parabola, form a vertex of the diagram. </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <param name="fortune">	The fortune. </param>
        </member>
        <member name="M:DAP.CompGeom.CircleEvent.Contains(DAP.CompGeom.PointD)">
             <summary>	Returns true if the circle event contains the passed in point. </summary>
            
             <remarks>	
             Darrell Plank, 2/21/2011. 
             </remarks>
            
             <param name="pt">	Point to check. </param>
            
             <returns>	True if its contained in the circle, else false. </returns>
        </member>
        <member name="T:DAP.CompGeom.FortunePoly">
             <summary>	Fortune polygon. </summary>
            
             <remarks>
             <para>I should point out that classic winged edge polygons don't keep a list of edges on each
             polygon.  They are enumerable through the Edges property.  Only a single arbitrary "starting"
             edge is kept in the polygon structure.  In general, that is the way winged edges work.  In
             the fortune case, we kind of come at the edges in an almost random manner so we keep them in
             a list.  The Edges enumeration should still work, though it's slower and unnecessary since
             you can just retrieve the list through FortunePoly.FortuneEdges.  We could end up with lower
             performance and less space by nulling out the array in the fortune polygons at the end of
             processing and relying on the Edges enumeration but we'd still need to keep the arrays around
             while we're actually creating the structure so I don't know how much real space we'd
             save.</para>
             
             Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="P:DAP.CompGeom.FortunePoly.FortuneEdges">
             <summary>	Gets or sets a list of edges in Clockwise order. </summary>
             <remarks>	
             Sadly, it was after creating and using this variable in numerous places that I found out that
             the "standard" order for keeping edges is in CCW order.  The enumerator at WePolygon was made
             with this convention in mind and thus returns the edges in CCW order so we have the confusion
             that one edge enumerator returns edges in CW order and one in CCW order.  Given that they're
             both used so heavily it would be tough to remove or modify either one.  I've made this one
             internal to avoid confusion externally. 
             </remarks>
            
             <value>	The edges in Clockwise order. </value>
        </member>
        <member name="M:DAP.CompGeom.FortunePoly.AddEdge(DAP.CompGeom.FortuneEdge)">
             <summary>	Adds an edge to the Fortune polygon. </summary>
            
             <remarks>	Darrellp, 2/22/2011. </remarks>
            
             <param name="edge">	The edge to be added. </param>
        </member>
        <member name="P:DAP.CompGeom.FortunePoly.VertexCount">
             <summary>	Gets the number of vertices. </summary>
            
             <value>	The number of vertices. </value>
        </member>
        <member name="P:DAP.CompGeom.FortunePoly.FAtInfinity">
             <summary>	Indicates that this is the singleton polygon at infinity </summary>
            
             <value>	true if at it's the polygon at infinity. </value>
        </member>
        <member name="P:DAP.CompGeom.FortunePoly.FZeroLengthEdge">
             <summary>	Tells whether we detected a zero length edge during the fortune processing </summary>
            
             <value>	true if zero length edge is present </value>
        </member>
        <member name="P:DAP.CompGeom.FortunePoly.VoronoiPoint">
             <summary>	The original point which caused this voronoi cell to exist. </summary>
            
             <value>	The point in the original set of data points. </value>
        </member>
        <member name="P:DAP.CompGeom.FortunePoly.Index">
             <summary>	A generic index to identify this polygon for debugging purposes.. </summary>
            
             <value>	The index. </value>
        </member>
        <member name="M:DAP.CompGeom.FortunePoly.BoxVertices(DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	
             Clip this voronoi cell with a passed in bounding box. 
             </summary>
            
             <remarks>	
             <para>I'm trying to handle all the exceptional cases.  There is one incredibly exceptional
             case which I'm ignoring.  That is the case where there are two vertices at infinity which are
             at such nearly opposite directions without being completely collinear that we can't push
             their points at infinity out far enough to encompass the rest of the box within the range of
             a double.  If this is important to you, then see the comments below, but it's hard to imagine
             it ever arising.</para>
             
             <para>Editorial comment - The annoying thing about all of this is that, like in so much of
             computational geometry, the rarer and less significant the exceptional cases are, the more
             difficult they are to handle.  It's both a blessing and a curse - it means that the normal
             cases are generally faster, but it also makes it difficult to get excited about slogging
             through the tedious details of situations that will probably never arise in practice.  Still,
             in order to keep our noses clean, we press on regardless.</para>
             
             Darrellp, 2/26/2011. 
             </remarks>
            
             <param name="ptUL">	The upper left point of the box. </param>
             <param name="ptLR">	The lower right point of the box. </param>
            
             <returns>	An enumerable of real points representing the voronoi cell clipped to the box. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortunePoly.RealVertices(DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	
             Identical to BoxVertices if there are any infinite polygons/vertices involved.  In the case
             of a purely finite polygon, we return it unaltered. 
             </summary>
            
             <remarks>	
             This overload of RealVertices ensures that all vertices are finite in a foolproof way.  The
             overload of RealVertices that takes a double as a raylength relies on the caller guessing as
             to a sufficient ray length to ensure that our rays extend outside of whatever area they're
             interested in.  That's usually not possible to do in a foolproof way.  Also, it has problems
             with doubly infinite lines when the return value is interpreted as a polygon.  This routine
             doesn't necessarily clip to the box in question, but does guarantee that the finite polygon
             returned will properly cover it's assigned area in the box passed in.  On interior cells, it
             avoids the overhead of a clipping operation which is liable to happen outside of this call
             anyway.  This is the safest way of covering a box without necessarily clipping to it.
             
             Darrellp, 2/28/2011. 
             </remarks>
            
             <param name="ptUL">	The upper left point of the box. </param>
             <param name="ptLR">	The lower right point of the box. </param>
            
             <returns>	An enumerable of real points representing the polygon. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortunePoly.RealVertices(System.Double,DAP.CompGeom.PointD,DAP.CompGeom.PointD)">
             <summary>	Converts vertices to real vertices. </summary>
            
             <remarks>	
             This routine does nothing for polygons with no infinite vertices.  If there are no doubly
             infinite lines, it uses raylength to extend the rays.  If there are doubly infinite lines it
             uses the machinery above to produce a region.  No clipping is done but it's guaranteed is
             that the resultant polygon is finite and covers the polygon's portion which intersects the
             passed in box (assuming that rayLength is long enough).  This routine is fairly fast, works
             with doubly infinite lines but could fail for infinite regions in which rayLength is of
             insufficient size.  If you feel like raylength will handle all non-doubly infinite lines but
             you still have to deal with the doubly infinite case, this is a good choice - especially if
             perfomance is an issue.
             
             Darrellp, 3/1/2011. 
             </remarks>
            
             <param name="rayLength">	Length of the ray. </param>
             <param name="ptUL">			The upper left point of the box. </param>
             <param name="ptLR">			The lower right point of the box. </param>
            
             <returns>	An enumerable of real points representing the polygon. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortunePoly.RealVertices(System.Double)">
             <summary>	
             Return real vertices.  All vertices at infinity will be converted based on the passed ray
             length. 
             </summary>
            
             <remarks>	
             There are a bewildering number of overloads and variations on RealVertices.  They are all
             meant to convert infinite vertices to finite ones and return a list of those finite vertices.
             This one is the simplest and fastest but also the most unreliable.  It takes a rayLength and
             simply extends each infinite line out to the length passed in.  Depending on what is desired,
             this may be sufficient, however if the ray length is not chosen properly the rays may not
             extend far enough.  Also, if the points returned are looked at as a polygon to be filled,
             doubly infinite lines will return empty polygons since they will just exted out in opposite
             directions making a line segmennts.  In some situations, doubly infinite lines are not a
             concern and often in those cases, this is the overload of choice.  Otherwise you'll have to
             continue on to one of the other overloads.
             
             Darrellp, 2/23/2011. 
             </remarks>
            
             <param name="rayLength">	Length of the ray. </param>
            
             <returns>	An enumerable of real points representing the polygon. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortunePoly.#ctor(DAP.CompGeom.PointD,System.Int32)">
             <summary>	Constructor. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="pt">		The point which creates this polygon. </param>
             <param name="index">	The index to identiry this polygon. </param>
        </member>
        <member name="M:DAP.CompGeom.FortunePoly.SortEdges">
             <summary>	Sort the edges in Clockwise order. </summary>
            
             <remarks>	
             We do this partially by knowing that all the polygons in a Voronoi diagram are convex.  That
             means we can sort edges by measuring their angle around the generator for the polygon.  We
             have to pick the point to measure this angle carefully which is what
             WEEdge.PolyOrderingTestPoint() does.  We also have to make a special case for the rare doubly
             infinite lines (such as that created with only two generators).
             
             Darrellp, 2/18/2011. 
             </remarks>
        </member>
        <member name="M:DAP.CompGeom.FortunePoly.DetachEdge(DAP.CompGeom.FortuneEdge)">
             <summary>	Remove an edge. </summary>
            
             <remarks>	This really only makes much sense for zero length edges. </remarks>
            
             <param name="edge">	Edge to remove. </param>
        </member>
        <member name="M:DAP.CompGeom.FortunePoly.HandleZeroLengthEdges">
             <summary>	Sort out zero length edge issues. </summary>
            
             <remarks>	
             Zero length edges are a pain and have to be dealt with specially since they don't sort
             properly using normal geometrical position nor can "sidedness" be determined solely from
             their geometry (a zero length line has no "sides").  Instead, we have to look at the non-zero
             length edges around them and determine this information by extrapolating from those edges
             topological connection to this edge. 
             </remarks>
        </member>
        <member name="T:DAP.CompGeom.FortuneVertex">
             <summary>	Represents a winged edge vertex in the fortune algorithm. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="P:DAP.CompGeom.FortuneVertex.CtEdges">
             <summary>	Gets the count of edges abutting this vertex. </summary>
            
             <value>	The count of edges. </value>
        </member>
        <member name="P:DAP.CompGeom.FortuneVertex.FortuneEdges">
             <summary>	Gets the list of edges abutting this vertex. </summary>
            
             <value>	The list of edges. </value>
        </member>
        <member name="M:DAP.CompGeom.FortuneVertex.PolyThird(DAP.CompGeom.FortuneEdge)">
             <summary>	
             Finds the third polygon which created this vertex besides the two on each side of the passed
             in edge. 
             </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="edge">	Edge in question. </param>
            
             <returns>	The polygon "opposite" this edge. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortuneVertex.Add(DAP.CompGeom.FortuneEdge)">
             <summary>	
             Edges are assumed to be added in a Clockwise direction.  The first edge is random and has no
             particular significance. 
             </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="edge">	Next clockwise edge to add. </param>
        </member>
        <member name="M:DAP.CompGeom.FortuneVertex.PtAtOtherEnd(DAP.CompGeom.WeEdge)">
             <summary>	
             Return the point at the other end of the given edge.  If the opposite point is a point at
             infinity, a "real" point on that edge is created and returned. 
             </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="edge">	Edge to traverse. </param>
            
             <returns>	The point at the opposite end of the edge. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortuneVertex.ResetOrderedFlag">
             <summary>	Reset the ordered flag so we get ordered in the next call to OrderEdges() </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.FortuneVertex.CompareEdges(DAP.CompGeom.WeEdge,DAP.CompGeom.WeEdge)">
             <summary>	Compare edges clockwise around this vertex. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="e1">	The first WeEdge. </param>
             <param name="e2">	The second WeEdge. </param>
            
             <returns>	+1 if they are CW around the generator, -1 if they're CCW, 0 if neither. </returns>
        </member>
        <member name="M:DAP.CompGeom.FortuneVertex.OrderEdges">
             <summary>	Order the three edges around this vertex. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.FortuneVertex.InfiniteVertex(DAP.CompGeom.PointD,System.Boolean)">
             <summary>	Produce a vertex at infinity. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            
             <param name="ptDirection">	Direction for the vertex. </param>
             <param name="fNormalize">	If true we normalize, else not. </param>
            
             <returns>	The vertex at infinity. </returns>
        </member>
        <member name="T:DAP.CompGeom.InternalNode">
             <summary>	Internal node in the tree representing our beachline. </summary>
            
             <remarks>	
             Internal nodes represent edges developing in the voronoi diagram being created.  As such,
             they have a fortune edge which will ultimately end up in the winged edge representation and
             two winged edge polygons which will also end up in the final rep.  In terms of the beachline
             tree, leaf nodes represent individual polygons in the voronoi diagram and the edge
             corresponding to an internal node is the edge between polygons represented by the rightmost
             leaf node in it's left subtree and the leftmost leaf node in it's right subtree.  
             
             Keeping in mind the equivalence between the beachline, the tree representing the beachline and the
             evolving elements in the voronoi diagram is a big key to understanding this code and the
             Fortune algorithm in general.
             
             Darrellp, 2/18/2011. 
             </remarks>
        </member>
        <member name="M:DAP.CompGeom.InternalNode.CurrentEdgeXPos(System.Double)">
             <summary>	Current edge x coordinate position at the scan line height. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="yScanLine">	The y coordinate scan line. </param>
            
             <returns>	X coordinate where our edge crosses the scan line. </returns>
        </member>
        <member name="M:DAP.CompGeom.InternalNode.SetEdge(DAP.CompGeom.FortuneEdge)">
             <summary>	Sets our edge for this internal node. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="edge">	The edge. </param>
        </member>
        <member name="M:DAP.CompGeom.InternalNode.AddEdgeToPolygons(DAP.CompGeom.FortuneEdge)">
             <summary>	Adds an edge to the fortune polygons we abut. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="edge">	The edge. </param>
        </member>
        <member name="T:DAP.CompGeom.LeafNode">
             <summary>	Leaf node in the tree representation of our beachline. </summary>
            
             <remarks>
             In the beachline tree, leaf nodes represent individual polygons.  As such, they point at the
             FortunePoly which will eventually be placed in the winged edge rep.  The are removed when
             the parabolas for their neighbors become wide enough to eliminate them.  This is represented by
             a circle event on the queue.  We keep track of the circle event that pertains to our demise.
             Kinda morbid - I know.
             
             We also keep pointers to our left siblings and our right siblings.  One of these siblings will
             be an "immediate" sibling - i.e., the other sibling of our parent.  The other sibling will be
             further off and harder to find so keeping these pointers to both siblings speed things up.
             
             Keeping in mind the equivalence between the beachline, the tree representing the beachline and the
             evolving elements in the voronoi diagram is a big key to understanding this code and the
             Fortune algorithm in general.
             
             Darrellp, 2/18/2011. 
             </remarks>
        </member>
        <member name="M:DAP.CompGeom.LeafNode.RightBreak(System.Double)">
             <summary>	Figure out where the breakpoint to our right is. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="yScanLine">	Where the scan line resides currently. </param>
            
             <returns>	The X coordinate of the right breakpoint. </returns>
        </member>
        <member name="M:DAP.CompGeom.LeafNode.LeftBreak(System.Double)">
             <summary>	Figure out where the breakpoint to our left is. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="yScanLine">	Where the scan line resides currently. </param>
            
             <returns>	The X coordinate of the left breakpoint. </returns>
        </member>
        <member name="M:DAP.CompGeom.LeafNode.DeleteAssociatedCircleEvent(DAP.CompGeom.EventQueue)">
             <summary>	Remove the circle event which snuffs this node's parabola from the event queue. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="evq">	Event queue. </param>
        </member>
        <member name="M:DAP.CompGeom.LeafNode.SetCircleEvent(DAP.CompGeom.CircleEvent)">
             <summary>	Set the circle event which snuff's this node's parabola. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="cevt">	The cevt. </param>
        </member>
        <member name="M:DAP.CompGeom.LeafNode.InnFindSiblingEdge(System.Boolean)">
             <summary>	Locate the inner node which represents the edge on a selected side. </summary>
            
             <remarks>	
             We have to walk up the tree till we find an inner node whose polygon is identical to the
             polygon being created by our left sibling. 
             
             Darrellp, 2/18/2011. 
             </remarks>
            
             <param name="fLeftSibling">	Which side to locate. </param>
            
             <returns>	The inner node for the breakpoint. </returns>
        </member>
        <member name="M:DAP.CompGeom.LeafNode.LinkSiblingsTogether">
             <summary>	I'm being removed so link my sibling nodes together as siblings. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="T:DAP.CompGeom.Node">
             <summary>	Node in the tree representing our beachline. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.Node.#ctor">
             <summary>	Default constructor. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="P:DAP.CompGeom.Node.ImmediateSibling">
             <summary>	Gets our parent's other sibling. </summary>
            
             <value>	The sibling. </value>
        </member>
        <member name="P:DAP.CompGeom.Node.IsLeftChild">
             <summary>	Tells whether we're our parent's left child. </summary>
            
             <value>	true if is a left child, false if not. </value>
        </member>
        <member name="P:DAP.CompGeom.Node.IsLeaf">
             <summary>	Gets a value indicating whether this node is leaf. </summary>
            
             <value>	true if this object is leaf, false if not. </value>
        </member>
        <member name="P:DAP.CompGeom.Node.NdParent">
             <summary>	Gets or sets our parent node. </summary>
            
             <value>	The parent. </value>
        </member>
        <member name="P:DAP.CompGeom.Node.LeftChild">
             <summary>	Gets or sets our left child. </summary>
            
             <value>	The left child. </value>
        </member>
        <member name="P:DAP.CompGeom.Node.RightChild">
             <summary>	Gets or sets the right child. </summary>
            
             <value>	The right child. </value>
        </member>
        <member name="M:DAP.CompGeom.Node.SnipFromParent">
            <summary>	Remove pointers to parent and mark the node as an orphan. </summary>
        </member>
        <member name="T:DAP.CompGeom.WeEdge">
             <summary>	The Edge in a WingedEdge data structure. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.Cookie">
             <summary>	A place for users to store information. </summary>
            
             <value>	User specific info. </value>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.VtxStart">
             <summary>	Gets or sets the starting vertex for this edge. </summary>
            
             <value>	The starting vertex for this edge. </value>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.VtxEnd">
             <summary>	Gets or sets the ending vertex for this edge. </summary>
            
             <value>	The ending vertex for this edge. </value>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.EdgeCWSuccessor">
             <summary>	Gets or sets the successor edge in a CW direction. </summary>
            
             <value>	The successor edge in a CW direction. </value>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.EdgeCCWSuccessor">
             <summary>	Gets or sets the successor edge in a CCW direction. </summary>
            
             <value>	The successor edge in a CCW direction. </value>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.PolyRight">
             <summary>	Gets or sets the polygon to the right of this edge. </summary>
            
             <value>	The polygon to the right of this edge. </value>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.PolyLeft">
             <summary>	Gets or sets the polygon to the left of this edge. </summary>
            
             <value>	The polygon to the left of this edge. </value>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.EdgeCWPredecessor">
             <summary>	Gets or sets the predecessor edge in a CW direction. </summary>
            
             <value>	The predecessor edge in a CW direction. </value>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.EdgeCCWPredecessor">
             <summary>	Gets or sets the predecessor edge in a CCW direction. </summary>
            
             <value>	The predecessor edge in a CCW direction. </value>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.FAtInfinity">
             <summary>	Gets a value indicating whether this is an edge at infinity. </summary>
            
             <value>	true if the edge is at infinity, false if not. </value>
        </member>
        <member name="P:DAP.CompGeom.WeEdge.FRay">
             <summary>	Gets a value indicating whether this edge is a ray. </summary>
            
             <value>	true if it's a ray, false if not. </value>
        </member>
        <member name="M:DAP.CompGeom.WeEdge.Failure">
            <summary>
            Place to set breakpoint to observe failure in validation routines
            </summary>
            <returns></returns>
        </member>
        <member name="M:DAP.CompGeom.WeEdge.Validate">
            <summary>
            Validate the edge information
            </summary>
            <returns></returns>
        </member>
        <member name="M:DAP.CompGeom.WeEdge.FConnectsToEdge(DAP.CompGeom.WeEdge)">
             <summary>	Ensure that this edge connects to the passed in edge. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="edge">	Edge to check. </param>
            
             <returns>	True if this edge connects to the passed in edge, else false. </returns>
        </member>
        <member name="M:DAP.CompGeom.WeEdge.FLeftOf(DAP.CompGeom.PointD)">
             <summary>	
             Determine if a point is to the left of this edge when facing from the start vertex to the end
             vertex. 
             </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="pt">	Point to check out. </param>
            
             <returns>	true if it succeeds, false if it fails. </returns>
        </member>
        <member name="M:DAP.CompGeom.WeEdge.ToString">
             <summary>	
             Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />. 
             </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <returns>	
             A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />. 
             </returns>
        </member>
        <member name="M:DAP.CompGeom.WeEdge.CompareToVirtual(DAP.CompGeom.WeEdge)">
             <summary>	Virtual version of compare. </summary>
            
             <remarks>
             There's probably a better way to handle this with abstract classes or something but I'm not
             sure right off the bat what it is and this works fine so I'm leaving well enough alone.
             Darrellp, 2/18/2011.
             </remarks>
            
             <exception cref="T:System.Exception">	Thrown always. </exception>
            
             <param name="edge">	The edge to compare. </param>
            
             <returns>	Never returns. </returns>
        </member>
        <member name="M:DAP.CompGeom.WeEdge.Draw(System.Drawing.Graphics,System.Drawing.Pen,System.Single)">
             <summary>	Draw the edge onto a graphics object. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="g">					Graphics object to draw with. </param>
             <param name="pen">					Pen to draw the edge with. </param>
             <param name="infiniteLineLength">	Length long enough to guarantee we draw to the edge of
             									the Graphics area. </param>
        </member>
        <member name="T:DAP.CompGeom.WePolygon">
             <summary>	Polygons in a WingedEdge structure. </summary>
            
             <remarks>	
             <para>Essentially a pointer to a random edge in this polygon.  The other edges can be
             navigated to by following predecessor and successor fields in the edges.  An enumerator is
             supplied which does this for you.  We also supply one for the vertices.</para>
             
             Darrellp, 2/18/2011. 
             </remarks>
        </member>
        <member name="P:DAP.CompGeom.WePolygon.Cookie">
             <summary>	A place for users to store information. </summary>
            
             <value>	User specific info. </value>
        </member>
        <member name="P:DAP.CompGeom.WePolygon.FirstEdge">
             <summary>	Gets or sets the first edge of an enumeration. </summary>
            
             <value>	The first edge in an enumeration. </value>
        </member>
        <member name="P:DAP.CompGeom.WePolygon.Edges">
             <summary>	Gets the edges in clockwise order. </summary>
            
             <value>	The edges. </value>
        </member>
        <member name="P:DAP.CompGeom.WePolygon.OrientedEdges">
             <summary>	Gets oriented edges which gives the edge along with the direction to move on it. </summary>
            
             <value>	The oriented edges. </value>
        </member>
        <member name="P:DAP.CompGeom.WePolygon.Vertices">
             <summary>	Gets the vertices in clockwise order. </summary>
            
             <value>	The vertices. </value>
        </member>
        <member name="M:DAP.CompGeom.WePolygon.Failure">
            <summary>
            Place to set a breakpoint to detect failure in the validation routines
            </summary>
            <returns></returns>
        </member>
        <member name="M:DAP.CompGeom.WePolygon.FValidateEdgeIsAdjacent(DAP.CompGeom.WeEdge)">
             <summary>	Ensure that a given edge is adjacent to this polygon. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="edge">	Edge to be checked. </param>
            
             <returns>	True if the edge is adjacent, else false. </returns>
        </member>
        <member name="M:DAP.CompGeom.WePolygon.FValidateEdgesInOrder">
             <summary>	Ensure that all edges connect to each other. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <returns>	True if all edges connect in order, else false. </returns>
        </member>
        <member name="T:DAP.CompGeom.WePolygon.OrientedEdge">
             <summary>	
             Gives an edge along with an orientation showing whether it starts at the actual StartVertex
             or is reversed and starts at the EndVertex.  I wouldn't have to do this if I'd have used the
             half edge structure rather than winged edge.  Live and learn. 
             </summary>
            
             <remarks>	Darrellp, 2/22/2011. </remarks>
        </member>
        <member name="F:DAP.CompGeom.WePolygon.OrientedEdge.Forward">
            <summary> True if the edge travels from the StartVertex to the EndVertex.  If false
            then we should traverse the edge from the EndVertex to the StartVertex. </summary>
        </member>
        <member name="F:DAP.CompGeom.WePolygon.OrientedEdge.Edge">
            <summary> The edge in question </summary>
        </member>
        <member name="P:DAP.CompGeom.WePolygon.OrientedEdge.StartVtx">
             <summary>	Gets the start vertex. </summary>
            
             <value>	The start vertex. </value>
        </member>
        <member name="P:DAP.CompGeom.WePolygon.OrientedEdge.EndVtx">
             <summary>	Gets the end vertex. </summary>
            
             <value>	The end vertex. </value>
        </member>
        <member name="P:DAP.CompGeom.WePolygon.OrientedEdge.StartPt">
             <summary>	Gets the start point for this directed edge. </summary>
            
             <value>	The start point. </value>
        </member>
        <member name="P:DAP.CompGeom.WePolygon.OrientedEdge.EndPt">
             <summary>	Gets the end point for this directed edge. </summary>
            
             <value>	The end point. </value>
        </member>
        <member name="T:DAP.CompGeom.WePolygon.EdgeEnumerator">
             <summary>	
             The standard WingedEdge doesn't directly give the edges around a polygon so this is an
             enumerator for that. They are returned in CCW order. 
             </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="T:DAP.CompGeom.WePolygon.EdgeEnumerable">
             <summary>	An enumerator for the edges of a polygon in CCW order. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="T:DAP.CompGeom.WeVertex">
             <summary>	The vertex in a WingedEdge data structure. </summary>
            
             <remarks>	
             In order to accommodate edges that extend off the edge of the picture, we allow for two types
             of vertices - normal vertices and vertices at infinity.  Vertices at infinity really
             represent "directions" rather than true points and are normally associated with another (non-
             infinite) vertex in an edge. For a point at infinity, the coordinates don't represent the
             true coordinates of the "point" but rather represent a normal vertex in the proper direction.
             The ability to represent these points at infinity as psuedo-points is crucial to making the
             WingedEdge structure work out since many of the edges in that structure will be between a
             point in the B-rep and a ray to infinity from that point. The standard WingedEdge structure
             makes no accommodations for such things, but we have to in the Voronoi diagram.
             
             Darrellp, 2/18/2011. 
             </remarks>
        </member>
        <member name="P:DAP.CompGeom.WeVertex.FirstEdge">
             <summary>	Gets or sets the first edge for enumerating edges from this vertex. </summary>
            
             <value>	The first edge. </value>
        </member>
        <member name="P:DAP.CompGeom.WeVertex.Polygons">
             <summary>	Gets the polygons which contain this vertex. </summary>
            
             <value>	The polygons. </value>
        </member>
        <member name="P:DAP.CompGeom.WeVertex.Edges">
             <summary>	Gets the polygons which contain this vertex. </summary>
            
             <value>	The polygons. </value>
        </member>
        <member name="P:DAP.CompGeom.WeVertex.FAtInfinity">
             <summary>	Gets or sets a value indicating whether this is a point at infinity. </summary>
            
             <value>	true if a point at infinity, false if not. </value>
        </member>
        <member name="P:DAP.CompGeom.WeVertex.Pt">
             <summary>	Gets or sets the location of the ver. </summary>
            
             <value>	The point. </value>
        </member>
        <member name="P:DAP.CompGeom.WeVertex.Cookie">
             <summary>	A place for users to store information. </summary>
            
             <value>	User specific info. </value>
        </member>
        <member name="M:DAP.CompGeom.WeVertex.#ctor">
             <summary>	Default constructor. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="M:DAP.CompGeom.WeVertex.#ctor(DAP.CompGeom.PointD)">
             <summary>	Construct a vertex from a point. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="pt">	The point the vertex is located at. </param>
        </member>
        <member name="M:DAP.CompGeom.WeVertex.SetInfinite(System.Boolean)">
             <summary>	Make this a vertex at infinity. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
            <param name="fNormalize">	true to normalize. </param>
        </member>
        <member name="M:DAP.CompGeom.WeVertex.ConvertToReal(DAP.CompGeom.PointD,System.Double)">
             <summary>	Convert to real physical point</summary>
            
             <remarks>
             Points at infinity are just directions from real points.  Occasionally, though, we need a "real"
             point on the ray represented by the point at infinity.  This routine takes the starting point
             of the ray and the point at infinity and produces a point which lies on the ray.
             Darrellp, 2/18/2011. 
             </remarks>
            
             <param name="ptStart">				The starting point of the ray. </param>
             <param name="rayLength">			Length along the ray from the starting point to our produced point. </param>
            
             <returns>	A point on the ray different than the starting point. </returns>
        </member>
        <member name="M:DAP.CompGeom.WeVertex.ToString">
             <summary>	
             Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />. 
             </summary>
            
             <remarks>	Darrellp, 2/21/2011. </remarks>
            
             <returns>	
             A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />. 
             </returns>
        </member>
        <member name="M:DAP.CompGeom.WeVertex.FValidateEdgeIsAdjacent(DAP.CompGeom.WeEdge)">
             <summary>	Ensure that the passed in edge is adjacent to this vertex. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="edge">	Edge to check. </param>
            
             <returns>	True if the edge is adjacent, else false. </returns>
        </member>
        <member name="M:DAP.CompGeom.WeVertex.VtxOtherEnd(DAP.CompGeom.WeEdge)">
             <summary>	Find the vertex on the other end of an edge. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="edge">	Edge to check. </param>
            
             <returns>	Vertex at the other end of the edge. </returns>
        </member>
        <member name="T:DAP.CompGeom.WeVertex.EdgeEnumerator">
             <summary>	
             WingedEdge doesn't directly give the edges which contain this vertex so we give an
             enumerator for that. 
             </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
        </member>
        <member name="T:DAP.CompGeom.WeVertex.EdgeEnumerable">
             <summary>	The enumerable for EdgeEnumerator. </summary>
            
             <remarks>	Darrellp, 2/19/2011. </remarks>
        </member>
        <member name="T:DAP.CompGeom.WingedEdge`3">
             <summary>	
             Winged Edge data structure for representing a B-rep or "boundary representation".
             </summary>
            
             <remarks>
             Intuitively,
             a B-rep can be though of as the representation for a map of polygonal countries.  This is
             precisely what the voronoi diagram returns.  Winged Edge is a bit redundant in it's
             representation but provides a very flexible structure for working with the underlying B-rep.
             WingedEdge centers on the edges and represents each edge by the polygons on each side of it
             and the next edge in each of those polygons.  Geometrically, the information retained with
             each edge looks like:
             				\      /
             Other Edges		 \____/    Other Edges
             				 /    \
             				/      \
             The "WingedEdge" name comes from the resemblance of this diagram to a butterfly.
             
             The version here is not much more than a shell.  It has some validation routines and some
             navigation routines, but it's pretty much up to the user to set up the structure via adding
             Polygons, vertices and edges to the structure and ensuring that their fields are set up
             correctly.
             
             Darrellp, 2/18/2011.
             </remarks>
        </member>
        <member name="M:DAP.CompGeom.WingedEdge`3.#ctor">
             <summary>	Default constructor. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
        </member>
        <member name="P:DAP.CompGeom.WingedEdge`3.LstPolygons">
             <summary>	Gets or sets the list of contained polygons. </summary>
            
             <value>	The list of contained polygons. </value>
        </member>
        <member name="P:DAP.CompGeom.WingedEdge`3.LstEdges">
             <summary>	Gets or sets the list of contained edges. </summary>
            
             <value>	The list of contained edges. </value>
        </member>
        <member name="P:DAP.CompGeom.WingedEdge`3.LstVertices">
             <summary>	Gets or sets the list of contained vertices. </summary>
            
             <value>	The list of contained vertices. </value>
        </member>
        <member name="M:DAP.CompGeom.WingedEdge`3.Failure">
            <summary>
            Set a breakpoint in this routine to find out when Validate() fails.
            </summary>
            <returns>Always false</returns>
        </member>
        <member name="M:DAP.CompGeom.WingedEdge`3.Validate">
             <summary>	Validates the WingedEdge structure in several ways. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <returns>	true if the winged edge structure is valid. </returns>
        </member>
        <member name="M:DAP.CompGeom.WingedEdge`3.AddEdge(`1)">
             <summary>	Adds an edge. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="edge">	The edge to be added. </param>
        </member>
        <member name="M:DAP.CompGeom.WingedEdge`3.AddPoly(`0)">
             <summary>	Adds a polygon. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="polygon">	The polygon to be added. </param>
        </member>
        <member name="M:DAP.CompGeom.WingedEdge`3.AddVertex(`2)">
             <summary>	Adds a vertex. </summary>
            
             <remarks>	Darrellp, 2/18/2011. </remarks>
            
             <param name="vertex">	The vertex to be added. </param>
        </member>
    </members>
</doc>
